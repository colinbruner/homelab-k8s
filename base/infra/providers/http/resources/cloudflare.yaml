---
apiVersion: http.crossplane.io/v1alpha1
kind: ProviderConfig
metadata:
  name: http-cloudflare
spec:
  credentials:
    source: Secret
    secretRef:
      namespace: crossplane-system
      name: cloudflare
      key: token
---
apiVersion: http.crossplane.io/v1alpha2
kind: Request
metadata:
  name: create-dns
spec:
  providerConfigRef:
    name: http-cloudflare
  forProvider:
    # Injecting data from secrets is possible, simply use the following syntax: {{ name:namespace:key }} (supported for body and headers only)
    headers:
      Content-Type:
        - application/json
      Authorization:
        - ("Bearer {{ cloudflare:crossplane-system:token }}") # TODO: Create a secret with the token
    payload:
      baseUrl: https://api.cloudflare.com/client/v4/zones/f153ce63fd6ad281b16a3c674b51588f/dns_records 
      body: |
        {
          "comment": "Internal ArgoCD Server UI",
          "content": "192.168.10.240",
          "name": "argocd",
          "ttl": 0,
          "type": "A"
        }
    mappings:
      # Scenario 1: Action specified, method not specified (defaults to POST for CREATE)
      - action: CREATE # method: "POST" 
        body: |
          {
            comment: .payload.body.comment, 
            content: .payload.body.content, 
            name: .payload.body.name,
            ttl: .payload.body.ttl,
            type: .payload.body.type
          }
        url: .payload.baseUrl
        #headers:
        #  Content-Type:
        #    - application/json
        #  Authorization:
        #    - ("Bearer {{ auth:default:token }}")

      # Scenario 2: Action specified, method not specified (defaults to GET for OBSERVE)
      - action: OBSERVE # method: "GET"
        url: (.payload.baseUrl + "/" + (.response.body.result.id|tostring))

      # Scenario 3: Method specified, action not specified (PUT implies UPDATE)
      - action: UPDATE
        method: "PATCH"
        body: |
          {
            comment: .payload.body.comment, 
            content: .payload.body.content, 
            name: .payload.body.name,
            ttl: .payload.body.ttl,
            type: .payload.body.type
          }
        url: (.payload.baseUrl + "/" + (.response.body.result.id|tostring))

      # Scenario 4: Action specified, method not specified (defaults to DELETE for REMOVE)
      - action: REMOVE # method: "DELETE"
        url: (.payload.baseUrl + "/" + (.response.body.result.id|tostring))
    
    # expectedResponseCheck is optional. If not specified or if the type is "DEFAULT", 
    # the resource is considered up to date if the GET response containes the PUT body.
    # If specified, the JQ logic determines if the resource is up to date:
    # - If the JQ query is false, a PUT request is sent to update the resource.
    # - If true, the resource is considered up to date.
    #expectedResponseCheck:
    #  type: CUSTOM
    #  logic: |
    #    if .response.body.password == .payload.body.password
    #     and .response.body.age == 30
    #     and .response.headers."Content-Type" == ["application/json"]
    #     and .response.headers."X-Secret-Header"[0] == "{{ response-secret:default:extracted-header-data }}"
    #     then true 
    #     else false 
    #     end

    # isRemovedCheck is optional. If not specified or if the type is "DEFAULT", 
    # the resource is considered removed if the OBSERVE response after REMOVE has 404 status code.
    # If specified, the JQ logic determines if the resource is removed:
    # - If the JQ query is false, a REMOVE request is sent to remove the resource.
    # - If true, the resource is considered up to date.
    #isRemovedCheck:
    #  type: CUSTOM
    #  logic: |
    #    if .response.statusCode == 404
    #      and .response.body.error == "User not found"
    #      then true 
    #      else false 
    #      end

    # Secrets receiving patches from response data
    #secretInjectionConfigs: 
    #  - secretRef:
    #      name: response-secret
    #      namespace: default
    #    metadata:
    #      labels:
    #        managed-by: provider-http
    #      annotations:
    #        username: .body.username
    #    keyMappings:
    #      - secretKey: extracted-user-email
    #        responseJQ: .body.email
    #      - secretKey: extracted-header-data
    #        responseJQ: .headers."X-Secret-Header"[0]
    #    # setOwnerReference determines if the secret should be deleted when the associated resource is deleted.
    #    setOwnerReference: true
      
      #- secretRef:
      #    name: response-user-password
      #    namespace: default
      #  keyMappings:
      #    - secretKey: extracted-user-password
      #      responseJQ: .body.password
      #    - secretKey: extracted-user-age
      #      responseJQ: .body.age
